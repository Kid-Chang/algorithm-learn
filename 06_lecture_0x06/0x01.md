# 구현
큐를 구현할 때는 원소를 담을 큰 배열 한 개와 앞쪽, 뒤쪽을 가리킬 변수 두 개가 필요합니다.

추가하는 부분을 rear(뒤쪽) 
<br>제거하는 부분을 front(앞쪽)
```c++
const int MX = 1000005;
int dat[MX];
int head = 0, tail = 0;
//  head는 가장 앞에 있는 원소의 인덱스이고 tail은 가장 뒤에 있는 원소의 인덱스 + 1
// 값을 추가하면 tail 인덱스 증가
// 값을 제거하면 head 인덱스 증가
```

**큐의 크기는 tail - head로 쉽게 계산할 수 있습니다.**

## 원형 큐
### 만약 8칸짜리 큐를 만들었을 때
head가 5를 가리키고 있고 tail이 8을 가리키고 있어 dat의 5번지, 6번지, 7번지를 사용하고 있는 상황을 보면 앞쪽에 사용하지 않고 있는 공간이 많음에도 불구하고 더 이상 삽입을 할 수가 없습니다. 삽입을 하려면 dat[8]에 값을 써야 하는데 배열이 8칸이니 그럴 수가 없기 때문입니다.

이를 해결할 방법은 큐의 원소가 들어갈 배열을 원형으로 만드는 것입니다. 관념적으로는 배열이 원형인거고, 실제 구현을 할 땐 head나 tail이 7인 상태에서 1이 더해질 때 0번지로 다시 오도록 만들면 됩니다.

즉, dat의 5, 6, 7번지를 사용하는 상황에서 원소 1개가 추가되면 0번지를 점유하는 것입니다. 이렇게 원형의 배열을 가정하고 구현한 큐를 **원형 큐**(Circular Queue)라고 부릅니다.

> 실무에서 굳이 **STL을 쓰지 않고** 큐를 직접 구현해서 쓰겠다고 하면 원형 큐로 만드는게 좋습니다.


> 코딩테스트에서는 어차피 push의 최대 횟수가 정해져 있습니다. 그러면 배열의 크기를 push의 최대 횟수보다 크게 둬서 굳이 원형 큐를 만들지 않아도 되게끔 할 수 있습니다.

