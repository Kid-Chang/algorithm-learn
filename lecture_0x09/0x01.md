# 예시 

https://blog.encrypted.gg/941 참고

1. 시작하는 칸을 큐에 넣고 방문했다는 표시를 남김
2. 큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 칸에 대해 3번을 진행
3. 해당 칸을 이전ㅇ 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입
4. 큐가 빌 때 까지 2번을 반복

(최악의 경우) 모든 칸이 큐에 1번씩 들어가므로 시간복잡도는 칸이 N개 일때 O(N)

# utility 헤더에 있는 pair
```c++
int main(void){
    pair<int, int> t1 = make_pair(10, 13);
    pair<int, int> t2 = {4, 6};
    cout << t2.first << " << t2.second" << "\n"; // 4 6
    if(t2 < t1) cout << "t2 < t1";
}
```
make_pair로 값을 넣어줄 수도 있고, C++11 이상에서는 그냥 중괄호를 써서 쉽게 해결할 수 있습니다.
값의 접근은 각각 first, second를 부름으로서 가능하고 또 pair에는 미리 대소 관계가 설정되어 있어서 편합니다. **알아서 앞쪽의 값을 먼저 비교하고, 이후 뒤쪽의 값을 비교합니다.**


[예시 코드](./BFS_example.cpp) 
```
BFS 를 구축할 때 주의할 점
첫 번째, 시작점을 큐에 넣긴하는데 정작 방문했다는 표시를 남기지 않은 채로 진행하는 경우가 있습니다. 이렇게 되면 시작점을 두 번 방문할 수가 있습니다.

두 번째, 큐에 넣을 때 해당 칸에 방문했다는 표시를 남기지 않고 큐에서 빼낼 때 남기는 경우인데, 이렇게 되면 같은 칸이 큐에 여러 번 들어가게 되어서 시간 초과나 메모리 초과가 발생할 수 있습니다. 특히 이건 보통 예제로 주는 작은 케이스에서는 잘 돌아가다가 실제 제출을 했을 때 터지는 경우가 많기 때문에 주의해야 합니다.

세 번째, 앞의 코드에서 있던 nx, ny가 배열 바깥으로 벗어났는지에 대한 루틴을 아예 빼먹었거나, 아니면 이상하게 구현을 한 상황을 말합니다.
``````
 
 