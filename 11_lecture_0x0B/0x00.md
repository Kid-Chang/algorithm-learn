# 재귀
# 알고리즘 설명
하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

도미노에서 제일 앞의 도미노를 쓰러트리게 되면 모든 도미노가 쓰러질 것입니다. 그런데 왜 모든 도미노가 쓰러지는지를 설명해보라고 한다면 두 가지 방법이 있습니다. 

첫 번째 설명 방법은 1번 도미노가 쓰러지면 2번 도미노가 쓰러지고, 2번 도미노가 쓰러지면 3번 도미노가 쓰러지고, 3번 도미노가 쓰러지면 4번 도미노가 쓰러지고…. 이런 식으로 계속 진행되기 때문에 모든 도미노가 쓰러진다는 설명 방법입니다.

두 번째 설명 방법은 수학적 귀납법을 이용한 방법인데 '1번 도미노가 쓰러진다', 'k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다'가 참이니까 모든 도미노가 쓰러진다는 설명 방법입니다.

## 재귀에 대한 정보 1

함수의 인자로 어떤 것을 받고 어디까지 계산 한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함.
모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수르 만들 수 있음.

재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만 메모리/시간에서는 손해를 봄.

## 재귀에 대한 정보 2

한 함수가 자기 자신을 여러번 호출하게 되면 비효율적일 수 있음.
ex) 피보나치 수열
```c++
int fibo(int n) {
    if(n <= 1) return 1;
    return fibo(n-1) + fibo(n-2);
}
```

피보나치 문제의 경우에는 식을 별 생각없이 재귀로 구현했더니 자기 자신을 여러 번 호출하는 과정에서 중복된 계산이 계속 발생해 시간복잡도가 말도 안되게 커져버린 상황이고 이 문제는 재귀 대신 나중에 배울 다이나믹 프로그래밍이라는 방법을 이용해 우리의 상식대로 O(n)에 해결할 수 있습니다.

## 재귀에 대한 정보 3
재귀 함수가 자기 자신을 부를 때 스택 영역에 함수에 대한 정보가 누적됩니다. 
이때, 메모리 제한과 별개로 스택 영역의 메모리가 별도로 제한되는 경우도 있음. 
한 10만번 정도만 들어가도 스택 메모리에 함수에 대한 정보가 계속 쌓이다가 1MB를 넘겨서 제출해보면 런타임 에러가 발생합니다. 
**참고로 스택 메모리에는 지역 변수도 들어갑니다.**
